"""
Predictions page for RetentionAI Streamlit application.

This page provides interactive prediction interface including customer data input,
batch file upload, real-time prediction display, risk categorization,
confidence intervals, and prediction history tracking.
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
import sys
import logging
from datetime import datetime, timedelta
import json
import io

# Setup path for imports
current_dir = Path(__file__).parent
sys.path.append(str(current_dir.parent))

try:
    from config import MODELS_DIR
    from database import get_database_manager
    from predict import ChurnPredictor, load_best_model_from_mlflow
    from utils import save_json, load_json
except ImportError as e:
    st.error(f"Failed to import required modules: {e}")
    st.stop()

logger = logging.getLogger(__name__)


class PredictionsPage:
    """Interactive predictions page for RetentionAI."""
    
    def __init__(self):
        """Initialize the predictions page."""
        self.db_manager = get_database_manager()
        self.models_dir = Path(MODELS_DIR)
        
        # Initialize prediction history in session state
        if 'prediction_history' not in st.session_state:\n            st.session_state.prediction_history = []\n    \n    def get_sample_customer_data(self) -> Dict[str, Any]:\n        \"\"\"Get sample customer data for form population.\"\"\"\n        return {\n            'CustomerID': 'CUST_0001',\n            'Gender': 'Female',\n            'SeniorCitizen': 0,\n            'Partner': 'Yes',\n            'Dependents': 'No',\n            'Tenure': 24,\n            'PhoneService': 'Yes',\n            'MultipleLines': 'Yes',\n            'InternetService': 'Fiber optic',\n            'OnlineSecurity': 'No',\n            'OnlineBackup': 'Yes',\n            'DeviceProtection': 'No',\n            'TechSupport': 'No',\n            'StreamingTV': 'Yes',\n            'StreamingMovies': 'Yes',\n            'Contract': 'Month-to-month',\n            'PaperlessBilling': 'Yes',\n            'PaymentMethod': 'Electronic check',\n            'MonthlyCharges': 85.45,\n            'TotalCharges': 2051.25\n        }\n    \n    def render_customer_input_form(self) -> Optional[pd.DataFrame]:\n        \"\"\"Render customer data input form.\"\"\"\n        \n        st.markdown(\"### ðŸ‘¤ Customer Information\")\n        \n        with st.form(\"customer_input_form\"):\n            col1, col2, col3 = st.columns(3)\n            \n            with col1:\n                st.markdown(\"**Basic Information**\")\n                customer_id = st.text_input(\"Customer ID\", value=\"CUST_0001\")\n                gender = st.selectbox(\"Gender\", [\"Male\", \"Female\"])\n                senior_citizen = st.selectbox(\"Senior Citizen\", [0, 1], format_func=lambda x: \"Yes\" if x else \"No\")\n                partner = st.selectbox(\"Partner\", [\"Yes\", \"No\"])\n                dependents = st.selectbox(\"Dependents\", [\"Yes\", \"No\"])\n                tenure = st.number_input(\"Tenure (months)\", min_value=0, max_value=100, value=24)\n            \n            with col2:\n                st.markdown(\"**Services**\")\n                phone_service = st.selectbox(\"Phone Service\", [\"Yes\", \"No\"])\n                multiple_lines = st.selectbox(\"Multiple Lines\", [\"Yes\", \"No\", \"No phone service\"])\n                internet_service = st.selectbox(\"Internet Service\", [\"DSL\", \"Fiber optic\", \"No\"])\n                online_security = st.selectbox(\"Online Security\", [\"Yes\", \"No\", \"No internet service\"])\n                online_backup = st.selectbox(\"Online Backup\", [\"Yes\", \"No\", \"No internet service\"])\n                device_protection = st.selectbox(\"Device Protection\", [\"Yes\", \"No\", \"No internet service\"])\n            \n            with col3:\n                st.markdown(\"**Additional Services & Billing**\")\n                tech_support = st.selectbox(\"Tech Support\", [\"Yes\", \"No\", \"No internet service\"])\n                streaming_tv = st.selectbox(\"Streaming TV\", [\"Yes\", \"No\", \"No internet service\"])\n                streaming_movies = st.selectbox(\"Streaming Movies\", [\"Yes\", \"No\", \"No internet service\"])\n                contract = st.selectbox(\"Contract\", [\"Month-to-month\", \"One year\", \"Two year\"])\n                paperless_billing = st.selectbox(\"Paperless Billing\", [\"Yes\", \"No\"])\n                payment_method = st.selectbox(\n                    \"Payment Method\", \n                    [\"Electronic check\", \"Mailed check\", \"Bank transfer (automatic)\", \"Credit card (automatic)\"]\n                )\n            \n            # Financial information\n            st.markdown(\"**Financial Information**\")\n            fin_col1, fin_col2 = st.columns(2)\n            \n            with fin_col1:\n                monthly_charges = st.number_input(\"Monthly Charges ($)\", min_value=0.0, value=85.45, step=0.01)\n            with fin_col2:\n                total_charges = st.number_input(\"Total Charges ($)\", min_value=0.0, value=2051.25, step=0.01)\n            \n            # Form submission\n            submitted = st.form_submit_button(\"ðŸ”® Predict Churn\", type=\"primary\")\n            \n            if submitted:\n                # Create DataFrame from form data\n                customer_data = {\n                    'CustomerID': customer_id,\n                    'Gender': gender,\n                    'SeniorCitizen': senior_citizen,\n                    'Partner': partner,\n                    'Dependents': dependents,\n                    'Tenure': tenure,\n                    'PhoneService': phone_service,\n                    'MultipleLines': multiple_lines,\n                    'InternetService': internet_service,\n                    'OnlineSecurity': online_security,\n                    'OnlineBackup': online_backup,\n                    'DeviceProtection': device_protection,\n                    'TechSupport': tech_support,\n                    'StreamingTV': streaming_tv,\n                    'StreamingMovies': streaming_movies,\n                    'Contract': contract,\n                    'PaperlessBilling': paperless_billing,\n                    'PaymentMethod': payment_method,\n                    'MonthlyCharges': monthly_charges,\n                    'TotalCharges': total_charges\n                }\n                \n                return pd.DataFrame([customer_data])\n        \n        return None\n    \n    def render_batch_upload(self) -> Optional[pd.DataFrame]:\n        \"\"\"Render batch file upload interface.\"\"\"\n        \n        st.markdown(\"### ðŸ“„ Batch Upload\")\n        \n        # File upload\n        uploaded_file = st.file_uploader(\n            \"Upload CSV file with customer data\",\n            type=['csv'],\n            help=\"Upload a CSV file containing customer data for batch predictions\"\n        )\n        \n        if uploaded_file is not None:\n            try:\n                # Read uploaded file\n                df = pd.read_csv(uploaded_file)\n                \n                # Display file info\n                st.success(f\"âœ… File uploaded successfully: {len(df):,} records\")\n                \n                # Show preview\n                st.markdown(\"**Data Preview:**\")\n                st.dataframe(df.head(), use_container_width=True)\n                \n                # Data validation\n                required_columns = [\n                    'Gender', 'SeniorCitizen', 'Partner', 'Dependents', 'Tenure',\n                    'PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity',\n                    'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV',\n                    'StreamingMovies', 'Contract', 'PaperlessBilling', 'PaymentMethod',\n                    'MonthlyCharges', 'TotalCharges'\n                ]\n                \n                missing_columns = [col for col in required_columns if col not in df.columns]\n                \n                if missing_columns:\n                    st.error(f\"âŒ Missing required columns: {', '.join(missing_columns)}\")\n                    return None\n                \n                # Check data quality\n                quality_issues = []\n                \n                # Check for missing values\n                missing_count = df.isnull().sum().sum()\n                if missing_count > 0:\n                    quality_issues.append(f\"{missing_count} missing values\")\n                \n                # Check data types\n                if df['Tenure'].dtype not in ['int64', 'float64']:\n                    quality_issues.append(\"Tenure should be numeric\")\n                \n                if df['MonthlyCharges'].dtype not in ['int64', 'float64']:\n                    quality_issues.append(\"MonthlyCharges should be numeric\")\n                \n                if quality_issues:\n                    st.warning(f\"âš ï¸ Data quality issues detected: {', '.join(quality_issues)}\")\n                    st.info(\"Predictions may be less accurate. Consider cleaning the data first.\")\n                \n                # Prediction button\n                if st.button(\"ðŸ”® Predict All\", type=\"primary\", key=\"batch_predict\"):\n                    return df\n                \n            except Exception as e:\n                st.error(f\"âŒ Error reading file: {str(e)}\")\n                return None\n        \n        # Download sample template\n        st.markdown(\"**Need a template?**\")\n        if st.button(\"ðŸ“¥ Download Sample CSV\"):\n            sample_data = self.get_sample_customer_data()\n            sample_df = pd.DataFrame([sample_data])\n            \n            csv = sample_df.to_csv(index=False)\n            st.download_button(\n                label=\"Download CSV Template\",\n                data=csv,\n                file_name=\"customer_data_template.csv\",\n                mime=\"text/csv\"\n            )\n        \n        return None\n    \n    def load_model(self) -> Optional[ChurnPredictor]:\n        \"\"\"Load the best available model.\"\"\"\n        try:\n            # Try to load from production first\n            production_dir = self.models_dir / \"production\" / \"current\"\n            if production_dir.exists():\n                model_files = list(production_dir.glob(\"*.json\")) + list(production_dir.glob(\"*.pkl\"))\n                if model_files:\n                    predictor = ChurnPredictor(str(model_files[0]))\n                    return predictor\n            \n            # Fallback to training directories\n            training_dirs = sorted(self.models_dir.glob(\"training_*\"), reverse=True)\n            for training_dir in training_dirs:\n                model_files = list(training_dir.glob(\"*.json\")) + list(training_dir.glob(\"*.pkl\"))\n                if model_files:\n                    predictor = ChurnPredictor(str(model_files[0]))\n                    return predictor\n            \n            # Try MLflow if available\n            try:\n                predictor = load_best_model_from_mlflow(\"churn_prediction_experiments\")\n                return predictor\n            except:\n                pass\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error loading model: {e}\")\n            return None\n    \n    def make_predictions(self, df: pd.DataFrame) -> Optional[Dict[str, Any]]:\n        \"\"\"Make predictions on input data.\"\"\"\n        \n        with st.spinner(\"ðŸ”® Making predictions...\"):\n            try:\n                # Load model\n                predictor = self.load_model()\n                \n                if predictor is None:\n                    st.error(\"âŒ No trained model available. Please train a model first.\")\n                    return None\n                \n                # Make predictions\n                results = predictor.predict(df)\n                \n                # Add timestamp\n                results['prediction_timestamp'] = datetime.now().isoformat()\n                \n                # Store in prediction history\n                history_entry = {\n                    'timestamp': results['prediction_timestamp'],\n                    'num_predictions': len(df),\n                    'churn_rate': results['statistics']['churn_rate'],\n                    'high_risk_customers': results['statistics']['high_risk_customers']\n                }\n                \n                st.session_state.prediction_history.append(history_entry)\n                \n                # Keep only last 50 entries\n                if len(st.session_state.prediction_history) > 50:\n                    st.session_state.prediction_history = st.session_state.prediction_history[-50:]\n                \n                return results\n                \n            except Exception as e:\n                st.error(f\"âŒ Prediction failed: {str(e)}\")\n                logger.error(f\"Prediction error: {e}\")\n                return None\n    \n    def render_prediction_results(self, results: Dict[str, Any]) -> None:\n        \"\"\"Render prediction results.\"\"\"\n        \n        st.markdown(\"### ðŸŽ¯ Prediction Results\")\n        \n        predictions_df = results['predictions']\n        statistics = results['statistics']\n        \n        # Summary metrics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Total Predictions\", f\"{statistics['total_predictions']:,}\")\n        \n        with col2:\n            st.metric(\n                \"Churn Rate\", \n                f\"{statistics['churn_rate']:.1%}\",\n                delta=f\"{statistics['churn_rate']:.1%}\"\n            )\n        \n        with col3:\n            st.metric(\n                \"High Risk Customers\", \n                f\"{statistics['high_risk_customers']:,}\",\n                delta=f\"{statistics['high_risk_customers'] / statistics['total_predictions']:.1%}\"\n            )\n        \n        with col4:\n            avg_prob = statistics['avg_churn_probability']\n            st.metric(\n                \"Avg Churn Probability\", \n                f\"{avg_prob:.1%}\",\n                delta=f\"{'High' if avg_prob > 0.5 else 'Moderate' if avg_prob > 0.3 else 'Low'} Risk\"\n            )\n        \n        # Risk distribution\n        st.markdown(\"#### Risk Distribution\")\n        \n        risk_data = {\n            'Risk Level': ['Low', 'Medium', 'High'],\n            'Count': [\n                statistics['low_risk_customers'],\n                statistics['medium_risk_customers'],\n                statistics['high_risk_customers']\n            ],\n            'Color': ['#28a745', '#ffc107', '#dc3545']\n        }\n        \n        fig_risk = px.pie(\n            values=risk_data['Count'],\n            names=risk_data['Risk Level'],\n            title=\"Customer Risk Distribution\",\n            color_discrete_map={\n                'Low': '#28a745',\n                'Medium': '#ffc107',\n                'High': '#dc3545'\n            }\n        )\n        \n        col1, col2 = st.columns([1, 1])\n        \n        with col1:\n            st.plotly_chart(fig_risk, use_container_width=True)\n        \n        with col2:\n            # Probability distribution\n            fig_hist = px.histogram(\n                predictions_df,\n                x='churn_probability',\n                bins=20,\n                title=\"Churn Probability Distribution\",\n                labels={'churn_probability': 'Churn Probability', 'count': 'Number of Customers'}\n            )\n            st.plotly_chart(fig_hist, use_container_width=True)\n        \n        # Detailed results table\n        st.markdown(\"#### Detailed Predictions\")\n        \n        # Add risk color coding\n        def risk_color(row):\n            if row['risk_category'] == 'High':\n                return ['background-color: #ffebee'] * len(row)\n            elif row['risk_category'] == 'Medium':\n                return ['background-color: #fff8e1'] * len(row)\n            else:\n                return ['background-color: #e8f5e8'] * len(row)\n        \n        # Display options\n        display_cols = st.multiselect(\n            \"Select columns to display:\",\n            predictions_df.columns.tolist(),\n            default=['CustomerID', 'churn_prediction', 'churn_probability', 'risk_category'] if 'CustomerID' in predictions_df.columns else ['churn_prediction', 'churn_probability', 'risk_category'],\n            key=\"display_columns\"\n        )\n        \n        if display_cols:\n            # Sort by probability (highest first)\n            sorted_df = predictions_df.sort_values('churn_probability', ascending=False)\n            \n            # Display with styling\n            st.dataframe(\n                sorted_df[display_cols],\n                use_container_width=True,\n                hide_index=True\n            )\n            \n            # Download results\n            csv = sorted_df.to_csv(index=False)\n            st.download_button(\n                label=\"ðŸ“¥ Download Results CSV\",\n                data=csv,\n                file_name=f\"churn_predictions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                mime=\"text/csv\"\n            )\n    \n    def render_prediction_history(self) -> None:\n        \"\"\"Render prediction history.\"\"\"\n        \n        st.markdown(\"### ðŸ“Š Prediction History\")\n        \n        if not st.session_state.prediction_history:\n            st.info(\"No prediction history available. Make some predictions to see history.\")\n            return\n        \n        # Convert history to DataFrame\n        history_df = pd.DataFrame(st.session_state.prediction_history)\n        history_df['timestamp'] = pd.to_datetime(history_df['timestamp'])\n        \n        # Recent activity summary\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            total_predictions = history_df['num_predictions'].sum()\n            st.metric(\"Total Predictions Made\", f\"{total_predictions:,}\")\n        \n        with col2:\n            avg_churn_rate = history_df['churn_rate'].mean()\n            st.metric(\"Average Churn Rate\", f\"{avg_churn_rate:.1%}\")\n        \n        with col3:\n            recent_sessions = len(history_df[history_df['timestamp'] > (datetime.now() - timedelta(days=7))])\n            st.metric(\"Prediction Sessions (7d)\", recent_sessions)\n        \n        # History visualization\n        if len(history_df) > 1:\n            fig_history = make_subplots(\n                rows=2, cols=1,\n                subplot_titles=[\"Predictions Over Time\", \"Churn Rate Trend\"],\n                vertical_spacing=0.1\n            )\n            \n            # Predictions count over time\n            fig_history.add_trace(\n                go.Scatter(\n                    x=history_df['timestamp'],\n                    y=history_df['num_predictions'],\n                    mode='lines+markers',\n                    name='Predictions',\n                    line=dict(color='blue')\n                ),\n                row=1, col=1\n            )\n            \n            # Churn rate trend\n            fig_history.add_trace(\n                go.Scatter(\n                    x=history_df['timestamp'],\n                    y=history_df['churn_rate'] * 100,\n                    mode='lines+markers',\n                    name='Churn Rate (%)',\n                    line=dict(color='red')\n                ),\n                row=2, col=1\n            )\n            \n            fig_history.update_layout(\n                height=500,\n                title=\"Prediction Activity History\",\n                showlegend=True\n            )\n            \n            fig_history.update_xaxes(title_text=\"Time\", row=2, col=1)\n            fig_history.update_yaxes(title_text=\"Number of Predictions\", row=1, col=1)\n            fig_history.update_yaxes(title_text=\"Churn Rate (%)\", row=2, col=1)\n            \n            st.plotly_chart(fig_history, use_container_width=True)\n        \n        # History table\n        st.markdown(\"#### Recent Sessions\")\n        \n        # Format timestamp for display\n        display_history = history_df.copy()\n        display_history['timestamp'] = display_history['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')\n        display_history = display_history.sort_values('timestamp', ascending=False)\n        \n        # Rename columns for better display\n        display_history.columns = ['Timestamp', 'Predictions', 'Churn Rate', 'High Risk Count']\n        display_history['Churn Rate'] = (display_history['Churn Rate'] * 100).round(1).astype(str) + '%'\n        \n        st.dataframe(\n            display_history.head(10),\n            use_container_width=True,\n            hide_index=True\n        )\n        \n        # Clear history option\n        if st.button(\"ðŸ—‘ï¸ Clear History\", key=\"clear_history\"):\n            st.session_state.prediction_history = []\n            st.success(\"Prediction history cleared!\")\n            st.rerun()\n    \n    def render_confidence_intervals(self, results: Dict[str, Any]) -> None:\n        \"\"\"Render prediction confidence analysis.\"\"\"\n        \n        st.markdown(\"### ðŸŽ¯ Prediction Confidence Analysis\")\n        \n        predictions_df = results['predictions']\n        \n        # Confidence metrics\n        high_confidence = len(predictions_df[\n            (predictions_df['churn_probability'] > 0.8) | \n            (predictions_df['churn_probability'] < 0.2)\n        ])\n        \n        medium_confidence = len(predictions_df[\n            ((predictions_df['churn_probability'] >= 0.6) & (predictions_df['churn_probability'] <= 0.8)) |\n            ((predictions_df['churn_probability'] >= 0.2) & (predictions_df['churn_probability'] <= 0.4))\n        ])\n        \n        low_confidence = len(predictions_df) - high_confidence - medium_confidence\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\"High Confidence\", f\"{high_confidence:,}\", \n                     delta=f\"{high_confidence/len(predictions_df):.1%}\")\n        \n        with col2:\n            st.metric(\"Medium Confidence\", f\"{medium_confidence:,}\",\n                     delta=f\"{medium_confidence/len(predictions_df):.1%}\")\n        \n        with col3:\n            st.metric(\"Low Confidence\", f\"{low_confidence:,}\",\n                     delta=f\"{low_confidence/len(predictions_df):.1%}\")\n        \n        # Confidence distribution\n        confidence_data = {\n            'Confidence Level': ['High', 'Medium', 'Low'],\n            'Count': [high_confidence, medium_confidence, low_confidence],\n            'Color': ['#28a745', '#ffc107', '#dc3545']\n        }\n        \n        fig_confidence = px.bar(\n            x=confidence_data['Confidence Level'],\n            y=confidence_data['Count'],\n            title=\"Prediction Confidence Distribution\",\n            color=confidence_data['Confidence Level'],\n            color_discrete_map={\n                'High': '#28a745',\n                'Medium': '#ffc107',\n                'Low': '#dc3545'\n            }\n        )\n        \n        st.plotly_chart(fig_confidence, use_container_width=True)\n        \n        # Recommendations based on confidence\n        st.markdown(\"#### Recommendations\")\n        \n        if low_confidence > len(predictions_df) * 0.3:\n            st.warning(\"âš ï¸ High proportion of low-confidence predictions. Consider:\")\n            st.markdown(\"\"\"\n            - Collecting more features for these customers\n            - Reviewing model training with additional data\n            - Using ensemble methods for better confidence\n            \"\"\")\n        elif high_confidence > len(predictions_df) * 0.7:\n            st.success(\"âœ… High proportion of confident predictions. Model is performing well!\")\n        else:\n            st.info(\"â„¹ï¸ Balanced confidence distribution. Consider reviewing medium-confidence cases.\")\n    \n    def render_page(self) -> None:\n        \"\"\"Render the complete predictions page.\"\"\"\n        \n        # Input methods\n        input_method = st.selectbox(\n            \"Choose input method:\",\n            [\"Manual Input\", \"Batch Upload\"],\n            key=\"input_method_selection\"\n        )\n        \n        st.markdown(\"---\")\n        \n        customer_data = None\n        \n        if input_method == \"Manual Input\":\n            customer_data = self.render_customer_input_form()\n        else:\n            customer_data = self.render_batch_upload()\n        \n        # Make predictions if data is available\n        if customer_data is not None:\n            st.markdown(\"---\")\n            \n            results = self.make_predictions(customer_data)\n            \n            if results:\n                self.render_prediction_results(results)\n                \n                st.markdown(\"---\")\n                \n                self.render_confidence_intervals(results)\n        \n        # Always show prediction history\n        st.markdown(\"---\")\n        self.render_prediction_history()\n\n\ndef render_predictions_page():\n    \"\"\"Main function to render predictions page.\"\"\"\n    page = PredictionsPage()\n    page.render_page()\n\n\nif __name__ == \"__main__\":\n    render_predictions_page()